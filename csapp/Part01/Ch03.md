# 第 3 章 程序的机器级表示

计算机工业已经完成从 32 位到 64 位机器的过渡。32 位机器只能使用大概 4GB（2<sup>32</sup>字节）的随机访问存储器

> [!NOTE|style:flat|label:机器位数与内存大小的关系]

> 32 位机器可使用的内存地址空间范围大小为 2<sup>32</sup> 个地址，也就是 4 × 2<sup>10</sup> × 2<sup>10</sup> 个地址空间，而**每个地址空间本身指向一个字节**（这是计算机内存组织本身决定的，因为字节是计算机本身逻辑组织的最小单位。「位」可理解为物理组织上的最小单位。一个整数型数据对象，其大小为 4 个字节，说明存储该数据对象的地址和其相邻对象的地址间偏移为 4），因而这里内存大小可直接写作 4GB。
>
> 这里的辨析，可结合 [9.1 物理和虚拟内存](../Part02/Ch09.md#91-物理和虚拟寻址) 章节来理解：计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address，主存 PA）。
>
> 对于 64 位机器，其内存空间可以多达 256TB（2<sup>48</sup> 字节），而且很容易就能扩展至 16EB（2<sup>64</sup> 字节）。所以可以看到，机器可表示的内存空间大小实际和机器字长有很大的关系，机器字长决定了机器可表示的内存空间大小上限。

## 3.1 历史观点

## 3.2 程序编码

### 3.2.1 机器级代码

对于机器级编程，两种抽象尤为重要：

1. 指令集体系结构或指令集架构（Instruction Set Architecture, ISA）。用于定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

2. 虚拟内存。机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：

- **程序计数器**（通常称为“PC”，在 x86-64 中用 %rip 表示）给出将要执行的下一条指令在内存中的地址。

- 整数**寄存器文件**包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址（对应于 C 语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。

- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。

- 一组向量寄存器可以存放一个或多个整数或浮点数值。

### 3.2.2 代码示例

### 3.2.3 关于格式的注解

## 3.3 数据格式

由于是从 16 位体系结构扩展成 32 位的，Intel 用术语“字（word）”表示 16 位数据类型。因此，称 32 位数为“双字（double words）”，称 64 位数为“四字（quad words）”

| C 声明 | Intel 数据类型 | 汇编代码后缀 | 大小（字节） |
| :-: | :-: | :-: | :-: |
| `char` | 字节 | b | 1 |
| `short` | 字 | w | 2 |
| `int` | 双字 | l | 4 |
| `long` | 四字 | q | 8 |
| `char *` | 四字 | q | 8 |
| `float` | 单精度 | s | 4 |
| `double` | 双精度 | l | 8 |

后缀‘l’用来表示双字，因为 32 位数被看成是“长字（long word）”。注意，汇编代码也使用后缀‘l’来表示 4 字节整数和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

## 3.4 访问信息

一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的**通用目的寄存器**[^1]。这些寄存器用来存储整数数据和指针。

![](../assets/Ch03/image01.png)

<center>图 3-1 整数寄存器。所有 16 个寄存器的低位部分都可以作为字节、字（16 位）、双字（32 位）和四字（64 位）数字来访问</center>

对于诸多指令，比如复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标时，对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎样，对此有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；**生成 4 字节数字的指令会把高位 4 个字节置为 0**。后面这条规则是作为从 IA32 到 x86-64 的扩展的一部分而采用的。

### 3.4.1 操作数指令符

| 类型 | 格式 | 操作数值 | 名称 |
| :-: | :-: | :-: | :-: |
| 立即数 | $_Imm_ | _Imm_ | 立即数寻址 |
| 寄存器 | r_<sub>a</sub>_ | R[r_<sub>a</sub>_] | 寄存器寻址 |
| 存储器 | _Imm_ | M[_Imm_] | 绝对寻址 |
| 存储器 | (r_<sub>a</sub>_) | M[R[r_<sub>a</sub>_]] | 间接寻址 |
| 存储器 | _Imm_(r_<sub>b</sub>_) | M[_Imm_+R[r_<sub>b</sub>_]] | （基址+偏移量）寻址 |
| 存储器 | (r_<sub>b</sub>_, r_<sub>i</sub>_) | M[R[r_<sub>b</sub>_]+R[r_<sub>i</sub>_]] | 变址寻址 |
| 存储器 | _Imm_(r_<sub>b</sub>_, r_<sub>i</sub>_) | M[_Imm_+R[r_<sub>b</sub>_]+R[r_<sub>i</sub>_]] | 变址寻址 |
| 存储器 | (, r_<sub>i</sub>_, _s_) | M[R[r_<sub>i</sub>_]·_s_] | 比例变址寻址 |
| 存储器 | _Imm_(, r_<sub>i</sub>_, _s_) | M[_Imm_+R[r_<sub>i</sub>_]·_s_] | 比例变址寻址 |
| 存储器 | (r_<sub>b</sub>_, r_<sub>i</sub>_, _s_) | M[R[r_<sub>b</sub>_]+R[r_<sub>i</sub>_]·_s_] | 比例变址寻址 |
| 存储器 | _Imm_(r_<sub>b</sub>_, r_<sub>i</sub>_, _s_) | M[_Imm_+R[r_<sub>b</sub>_]+R[r_<sub>i</sub>_]·_s_] | 比例变址寻址 |

### 3.4.2 数据传送指令

最简单的数据传送指令——MOV 类。MOV 类由四条指令组成：`movb`、`movw`、`movl` 和 `movq`。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是 1、2、4 和 8 字节。

| 指令 | 效果 | 描述 |
|:-: | :-: | :-:| 
| `MOV S, D` | D ← S | 传送 |
| `movb` | | 传送字节 |
| `movw` | | 传送字 |
| `movl` | | 传送双字 |
| `movq` | | 传送四字 |
| `movabsq I, R` | R ← I | 传送绝对的四字 |

x86-64 的指令限制：传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。

大多数情况中，MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是 `movl` 指令以寄存器作为目的时，它会把该寄存器的高位 4 字节设置为 0。

上述表中记录的最后一条指令是处理 64 位立即数数据的。常规的 `movq` 指令只能以表示为 32 位补码数字的立即数作为源操作数，然后把这个值拓展得到 64 位的值放到目的位置。`movabsq` 指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的。

`cltq` 指令，其效果为 `%rax ← 符号拓展(%eax)`，即把 `%eax` 符号拓展到 `%rax`。需要注意的是，`cltq` 指令只作用于寄存器 `%eax` 和 `%rax`。

### 3.4.3 数据传送示例

C 语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。对于局部变量而言，通常是将其保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。

### 3.4.4 压入和弹出栈数据

| 指令 | 效果 | 描述 |
| :-: | :-: | :-: |
| `pushq S` | R[%rsp] ← R[%rsp] - 8;<br>M[R[%rsp]] ← S | 将四字压入栈 |
| `popq D` | D ← M[R[%rsp]];<br>R[%rsp] ← R[%rsp] + 8 | 将四字弹出栈 |

## 3.5 算术和逻辑操作

### 3.5.1 加载有效地址

**加载有效地址**（load effective address）指令 `leaq` 实际上是 `movq` 指令的变形。它的指令形式是从内存读数据到寄存器，但**实际上它根本就没有引用内存**。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器 %rdx 的值为 x，那么指令 `leaq 7(%rdx, %rdx, 4), %rax` 将设置寄存器 %rax 的值为 5x + 7。编译器经常发现 leaq 的一些灵活用法，根本就与有效地址计算无关。目的操作数必须是一个寄存器。

### 3.5.2 一元和二元操作

### 3.5.3 移位操作

### 3.5.4 讨论

对于大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作需要区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

### 3.5.5 特殊的算术操作

## 3.6 控制

### 3.6.1 条件码

### 3.6.2 访问条件码

### 3.6.3 跳转指令

### 3.6.4 跳转指令的编码

### 3.6.5 用条件控制来实现条件分支

### 3.6.6 用条件传送来实现条件分支

### 3.6.7 循环

### 3.6.8 switch 语句

## 3.7 过程

### 3.7.1 运行时栈

### 3.7.2 转移控制

### 3.7.3 数据传送

### 3.7.4 栈上的局部存储

### 3.7.5 寄存器中的局部存储空间

### 3.7.6 递归过程

## 3.8 数组分配和访问

### 3.8.1 基本原则

### 3.8.2 指针运算

### 3.8.3 嵌套的数组

### 3.8.4 定长数组

### 3.8.5 变长数组

## 3.9 异质的数据结构

### 3.9.1 结构

### 3.9.2 联合

### 3.9.3 数据对齐

## 3.10 在机器级程序中将控制与数据结合起来

### 3.10.1 理解指针

### 3.10.2 应用：使用 GDB 调试器

### 3.10.3 内存越界引用和缓冲区溢出

### 3.10.4 对抗缓冲区溢出攻击

### 3.10.5 支持变长栈帧

## 3.11 浮点代码

### 3.11.1 浮点传送和转换操作

### 3.11.2 过程中的浮点代码

### 3.11.3 浮点运算操作

### 3.11.4 定义和使用浮点常数

### 3.11.5 在浮点代码中使用位级操作

### 3.11.6 浮点比较操作

### 3.11.7 对浮点代码的观察结论

## 3.12 小结

[^1]: 如图片丢失，亦可参考附录文字版寄存器说明图：[通用目的寄存器布局](../Others/Appendix.md#通用寄存器布局文字版)
