# 第 5 章 优化程序性能

编写高效程序需要做到以下几点：

第一，必须选择一组适当的算法和数据结构。第二，必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。

现代编译器采用了复杂的分析和优化形式，而且变得越来越好。然而，即使是最好的编译器也受到**妨碍优化的因素**（optimization blocker）的阻碍，妨碍优化的因素就是程序行为中那些严重依赖于执行环境的方面。程序员必须编写容易优化的代码，以帮助编译器。

## 5.1 优化编译器的能力和局限性

两个指针可能指向同一个内存位置的情况称为**内存别名使用**（memory aliasing）。在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中同一个位置。这造成了一个主要的**妨碍优化的因素**，也是可能严重限制编译器产生优化代码机会的程序的一个方面。

第二个妨碍优化的因素是函数调用。大多数编译器不会试图判断一个函数是否没有副作用，如果没有，就有可能被优化。如果有，编译器会假设最高的情况，并保持所有的函数调用不变。

## 5.2 表示程序性能

## 5.3 程序示例

## 5.4 消除循环的低效率

- 代码移动（code motion）

## 5.5 减少过程调用

对于原书示例中的 `get_vec_element` 来说，每次调用以获取线性表中的单个元素。为了保证程序的健壮性，`get_vec_element`中不可避免地需要对索引进行合理性判断（比如索引下标是否在线性表的合理下标范围内）。而正是这个检查过程本身带来了程序的额外开销。

对于模块性开发来说，使用 `get_vec_element` 可以更好地对“过程”进行封装，使得调用者不必在意其实现细节；同时也避免了调用者对可能潜在的漏洞进行恶意利用。因而从健壮性、模块化角度来讲，这个封装带来的效率成本是值得的。而对于一些开发者（他们的利益是和接口提供者一致的，因而不存在针对安全性等心怀恶意的情况）来说，为了更好地提高程序性能，这样的过程开销反而是一种不必要的负担（因为他们可以通过其他手段来确保安全性，比如确定了线性表的首尾，扫描中间元素时就可以确保每次访问都是安全的）。

所以，这就是开发者经常会遇到的取舍。对于很多实际场景与问题，常常可以得到一个宏观上合理且适用的方案，但对于诸多细节，依然需要开发者对实际场景进行评估与取舍。

原书中，提出此部分，即 `get_vec_element` 并未造成性能上的下降，针对具体原因，后续章节会有解释说明。而对这个接口的分析结论，是明确且有价值的。如果接口内本身会有额外的开销，就需要注意这部分开销本身是否是一个可接受的成本。

## 5.6 消除不必要的内存引用

一些场景下，使用临时局部变量来缓存运算结果，求值效率可能是更优的。因为过程本身避免了指令的访存，进而简化了程序执行上的开销。编译器可能不会用局部变量（分配寄存器）缓存的原因，依然是目的内存地址，可能和待计算的元素地址相同或相交（比如将数组 `arr[]` 的值求和缓存至 `*dest`，而 `dest` 的值可能是 `arr[len(arr)-1]`）。

## 5.7 理解现代处理器

虽然我们看上去，代码是一行一行执行的，编译生成的相关指令也是一条一条执行的，而实际上，处理器是同时对多条指令求值的，这个现象被称为 **指令级并行**。现代微处理器取得的了不起的功绩之一就是：它们采用复杂而又奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现出一种简单的顺序执行指令的表象。

### 5.7.1 整体操作

### 5.7.2 功能单元的性能

### 5.7.3 处理器操作的抽象模型

## 5.8 循环展开

**k × 1 循环展开**：循环展开因子为 _k_，而累计值只在单个变量 acc 中。

> [!NOTE|label:让编译器展开循环]
>
> 编译器可以很容易地执行循环展开。只要优化级别设置得足够高，许多编译器都能例行公事地做到这一点。用优化等级 3 或更高等级调用 GCC，它就会执行循环展开。

## 5.9 提高并行性

### 5.9.1 多个累积变量

### 5.9.2 重新结合变换

## 5.10 优化合并代码的结果小结

## 5.11 一些限制因素

### 5.11.1 寄存器溢出

### 5.11.2 分支预测和预测错误处罚

#### 1. 不要过分关心可预测的分支

#### 2. 书写适合用条件传送实现的代码

假设给定两个整数数组 a 和 b，对于每个位置 _i_，将 a[_i_] 设置为 a[_i_] 和 b[_i_] 中较小的那一个，而将 b[_i_] 设置为两者中较大的那一个。

- 实现 1：命令式风格

```c
void minmax1(long a[], long b[], long n) {
    long i;
    for (i = 0; i < n; ++i) {
        if (a[i] > b[i]) {
            long t = a[i];
            a[i] = b[i];
            b[i] = t;
        }
    }
}
```

在随机数据上测试这个函数，其 CPE 大约为 13.50，而对于可预测的数据，CPE 为 2.5 ~ 3.5，其预测错误惩罚约为 20 个周期。

- 实现 2：功能式风格

```c
void minmax2(long a[], long b[], long n) {
    long i;
    for (i = 0 ; i < n; ++i) {
        long min = a[i] < b[i] ? a[i] : b[i];
        long max = a[i] < b[i] ? b[i] : a[i];
        a[i] = min;
        b[i] = max;
    }
}
```

对于这个函数的测试，无论数据是任意的还是可预测的，CPE 都大约为 4.0。

## 5.12 理解内存性能

### 5.12.1 加载的性能

### 5.12.2 存储的性能

## 5.13 应用：性能提高技术

一些优化程序性能的基本策略：

1. **高级设计** 为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。

2. **基本编码原则** 避免限制优化的因素，这样编译器就能产生高效的代码。

    - 消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获得更大的效率。

    - 消除不必要的内存引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中。

3. **低级优化** 结构化代码以利用硬件功能。

    - 展开循环，降低开销，并且使得进一步的优化成为可能。

    - 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。

    - 用功能性的风格重写条件操作，使得编译采用条件数据传送。

## 5.14 确认和消除性能瓶颈

### 5.14.1 程序剖析

### 5.14.2 使用剖析程序来指导优化

## 5.15 小结
