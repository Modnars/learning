# 第 4 章 处理器体系结构

冒险：一条指令的位置或操作数依赖于其他仍在流水线中的指令。

## 4.1 Y86-64 指令集体系结构

定义一个指令集体系结构（例如 Y86-64）包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

### 4.1.1 程序员可见的状态

### 4.1.2 Y86-64 指令

指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。这里给定的前提是指令的起点是明确的，且能够明确确定单条执行指令的长度（对齐自然是最佳）。也就是说，如果不能明确一段代码序列的起始位置，就不能准确地确定如何将序列划分成单独的指令。

> [!NOTE|label:比较 x86-64 和 Y86-64 的指令编码]
>
> 同 x86-64 中的指令编码相比，Y86-64 的编码简单得多，但是没有那么紧凑。
>

~

> [!NOTE|label:RISC 和 CISC 指令集]
>
> x86-64 有时称为“复杂指令集计算机”（CISC），与“精简指令集计算机”（RISC）相对。从历史上看，CISC 要早于 RISC 指令集出现。
>
> 比较 CISC 和最初的 RISC 指令集，有如下基本特性：
> 
> | CISC | 早期的 RISC |
> | :-: | :-: |
> | 指令数量很多。Intel 描述全套指令的文档有 1200 多页 | 指令数量少得多。通常少于 100 个。|
> | 有些指令的延迟很长。包括将一个整块从内存的一个部分复制到另一部分的指令，以及其他一些将多个寄存器的值复制到内存或从内存复制到多个寄存器的指令 | 没有较长延迟的指令。有些早期的 RISC 机器甚至没有整数乘法指令，要求编译器通过一系列加法来实现乘法。 |
> | 编码是可变长度的。x86-64 的指令长度可以是 1~15 个字节 | 编码是固定长度的。通常所有的指令都编码为 4 个字节 |
> | 制定操作数的方式很多样。在 x86-64 中，内存操作数指示符可以有许多不同的组合，这些组合由偏移量、基址和变址寄存器以及伸缩因子组成 | 简单寻址方式。通常只有基址和偏移量寻址 |
> | 可以对内存和寄存器操作数进行算术和逻辑运算 | 只能对寄存器操作数进行算术和逻辑运算。允许使用内存引用的只有 load 和 store 指令，load 是从内存读到寄存器，store 是从寄存器写到内存。这种方法被称为 load/store 体系结构。 |
> | 对机器级程序来说实现细节是不可见的。ISA 提供了程序和如何执行程序之间的清晰的抽象。 | 对机器级程序来说实现细节是可见的。有些 RISC 机器禁止某些特殊的指令序列，而有些跳转要到下一条指令执行完了以后才会生效。编译器必须在这些约束条件下进行性能优化。 |
> | 有条件码。作为指令执行的副产品，设置了一些特殊的标志位，可以用于条件分支检测。 | 没有条件码。相反，对条件检测来说，要用明确的测试指令，这些指令会将测试结果放在一个普通的寄存器中。 |
> | 栈密集的过程链接。栈被用来存取过程参数和返回地址。 | 寄存器密集的过程链接。寄存器被用来存取过程参数和返回地址。因此有些过程能完全避免内存引用。通常处理器有更多的（最多的有 32 个）寄存器。 |

Y86-64 指令集既有 CISC 指令集的属性，也有 RISC 指令集的属性。和 CISC 一样，它有条件码、长度可变的指令，并用栈来保存返回地址。和 RISC 一样的是，它采用 load/store 体系结构和规则编码，通过寄存器来传递过程参数。Y86-64 指令集可以看成是采用 CISC 指令集（x86），但又根据某些 RISC 的原理进行了简化。

### 4.1.3 指令编码

### 4.1.4 Y86-64 异常

### 4.1.5 Y86-64 程序

### 4.1.6 一些 Y86-64 指令的详情

## 4.2 逻辑设计和硬件控制语言 HCL

### 4.2.1 逻辑门

### 4.2.2 组合电路和 HCL 布尔表达式

### 4.2.3 字级的组合电路和 HCL 整数表达式

### 4.2.4 集合关系

### 4.2.5 存储器和时钟

- **时钟寄存器**（简称**寄存器**）存储单个位或字。时钟信号控制寄存器加载输入值。

- **随机访问存储器**（简称**内存**）存储多个字，用地址来选择该读或该写那个字。随机访问存储器的例子包括：

    1. 处理器的虚拟内存系统，硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字
    2. 寄存器文件，在此，寄存器标识符作为地址。在 IA32 或 Y86-64 处理器中，存储器文件有 15 个程序寄存器（%rax~%r14）

## 4.3 Y86-64 的顺序实现

SEQ 执行处理一条完整指令所需的所有步骤。当然，这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。但开发 SEQ 的目标就是提供实现最终目的的第一步，最终目的依然是实现一个高效的、流水线化的处理器。

### 4.3.1 将处理组织成阶段

通常，处理一条指令需要很多步骤，如果能将它们抽象组织成一个处理步骤阶段序列，也就是说，即使不同指令动作间的差异很大，他们的处理流程依然遵循同样的处理序列，在这样的框架下，就可以设计出一个充分利用硬件的处理器。

下面是关于各个阶段以及各阶段内执行的操作的简略描述：

- **取指**（fetch）：取指阶段从内存读取指令字节，地址为程序计数器（PC）的值。从指令中抽取出指令指示符字节的两个四位部分，称为 icode（指令代码）和 ifun（指令功能）。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符 rA 和 rB。它还可能取出一个四字节常数字 valC。它按顺序方式计算当前指令的下一条指令的地址 valP。也就是说，valP 等于 PC 的值加上已取出指令的长度。

- **译码**（decode）：译码阶段从寄存器文件读入最多两个操作数，得到值 valA 和（或）valB。通常，它读入指令 rA 和 rB 字段指明的寄存器，不过有些指令是读寄存器 %rsp 的。 

- **执行**（execute）：在执行阶段，算术 / 逻辑单元（ALU）要么执行指令指明的操作（根据 ifun 的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值将其称为 valE。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检验条件码和传送条件（由 ifun 给出），如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。

- **访存**（memory）：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为 valM。

- **写回**（write back）：写回阶段最多可以写两个结果到寄存器文件。

- **更新 PC**（PC update）：将 PC 设置成下一条指令的地址。

处理器无限循环，执行这些阶段。在此处的简化实现中，发生任何异常时，处理器就会停止：它执行 halt 指令或非法指令，或它试图读或者写非法地址。在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型决定的特殊代码。

| 阶段 | OPq rA, rB | rrmovq rA, rB | irmovq V, rB |
| :-: | :-- | :-- | :-- |
| 取指 | icode : ifun ← M<sub>1</sub>[PC]<br>rA : rB ← M<sub>1</sub>[PC+1]<br>valP ← PC + 2 | icode : ifun ← M<sub>1</sub>[PC]<br>rA : rB ← M<sub>1</sub>[PC+1]<br>valP ← PC + 2 | icode : ifun ← M<sub>1</sub>[PC]<br>rA : rB ← M<sub>1</sub>[PC+1]<br>valC ← M<sub>8</sub>[PC+2]<br>valP ← PC + 10 |
| 译码 | valA ← R[rA]<br>valB ← R[rB] | valA ← R[rA] | |
| 执行 | valE ← valB OP valA<br>Set CC | valE ← 0 + valA | valE ← 0 + valC |
| 访存 | | | |
| 写回 | R[rB] ← valE | R[rB] ← valE | r[rB] ← valE |
| 更新 PC | PC ← valP | PC ← valP | PC ← valP | 

| 阶段 | rmmovq rA, D(rB) | mrmovq D(rB), rA |
| :-: | :-- | :-- |
| 取指 | icode : ifun ← M<sub>1</sub>[PC]<br>rA : rB ← M<sub>1</sub>[PC+1]<br>valC ← M<sub>8</sub>[PC+2]<br>valP ← PC + 10 | icode : ifun ← M<sub>1</sub>[PC]<br>rA : rB ← M<sub>1</sub>[PC+1]<br>valC ← M<sub>8</sub>[PC+2]<br>valP ← PC + 10 |
| 译码 | valA ← R[rA]<br>valB ← R[rB] | valB ← R[rB] |
| 执行 | valE ← valB + valC | valE ← valB + valC |
| 访存 | M<sub>8</sub>[valE] ← valA | valM ← M<sub>8</sub>[valE] |
| 写回 | | R[rA] ← valM |
| 更新 PC | PC ← valP | PC ← valP |

| 阶段 | pushq rA | popq rA |
| :-: | :-- | :-- |
| 取指 | icode : ifun ← M<sub>1</sub>[PC]<br>rA : rB ← M<sub>1</sub>[PC+1]<br>valP ← PC + 2 | icode : ifun ← M<sub>1</sub>[PC]<br>rA : rB ← M<sub>1</sub>[PC+1]<br>valP ← PC + 2 |
| 译码 | valA ← R[rA]<br>valB ← R[%rsp] | valA ← R[%rsp]<br>valB ← R[%rsp] |
| 执行 | valE ← valB + (-8) | valE ← valB + 8 |
| 访存 | M<sub>8</sub>[valE] ← valA | valE ← M<sub>8</sub>[valA] |
| 写回 | R[%rsp] ← valE | R[%rsp] ← valE<br>R[rA] ← valM |
| 更新 PC | PC ← valP | PC ← valP |

| 阶段 | jXX Dest | call Dest | ret |
| :-: | :-- | :-- | :-- |
| 取指 | icode : ifun ← M<sub>1</sub>[PC]<br>valC ← M<sub>8</sub>[PC+1]<br>valP ← PC + 9 | icode : ifun ← M<sub>1</sub>[PC]<br>valC ← M<sub>8</sub>[PC+1]<br>valP ← PC + 9 | icode : ifun ← M<sub>1</sub>[PC]<br>valP ← PC + 1 |
| 译码 | | valB ← R[%rsp] | valA ← R[%rsp]<br>valB ← R[%rsp] |
| 执行 | Cnd ← Cond(CC, ifun) | valE ← valB + (-8) | valE ← valB + 8 |
| 访存 | | M<sub>8</sub>[valE] ← valP | valM ← M<sub>8</sub>[valA] |
| 写回 | | R[%rsp] ← valE | R[%rsp] ← valE |
| 更新 PC| PC ← Cnd ? valC : valP | PC ← valC | PC ← valM |

### 4.3.2 SEQ 硬件结构

### 4.3.3 SEQ 的时序

### 4.3.4 SEQ 阶段的实现

## 4.4 流水线的通用原理

流水线化的一个重要特性就是提高了系统的**吞吐量**（throughput），也就是单位时间内服务的顾客总数，不过它也会轻微地增加**延迟**（latency），也就是服务一个用户所需要的时间。

### 4.4.1 计算流水线

### 4.4.2 流水线操作的详细说明

### 4.4.3 流水线的局限性

1. 不一致的划分

2. 流水线过深，收益反而下降

### 4.4.4 带反馈的流水线系统

## 4.5 Y86-64 的流水线实现

### 4.5.1 SEQ+：重新安排计算阶段

### 4.5.2 插入流水线寄存器

### 4.5.3 对信号进行重新排列和标号

### 4.5.4 预测下一个 PC

### 4.5.5 流水线冒险

冒险分为两类：**数据冒险**（data hazard）和**控制冒险**（control hazard）。

### 4.5.6 异常处理

### 4.5.7 PIPE 各阶段的实现

### 4.5.8 流水线控制逻辑

### 4.5.9 性能分析

### 4.5.10 未完成的工作

## 4.6 小结
